<?xml version="1.0" encoding="UTF-8"?>
<solver>
    <solutionClass>com.example.domain.SchoolSchedule</solutionClass>
    <!-- UPDATED: Changed from CourseAssignment to CourseBlockAssignment for block-based scheduling -->
    <entityClass>com.example.domain.CourseBlockAssignment</entityClass>
    <scoreDirectorFactory>
        <constraintProviderClass>com.example.solver.SchoolConstraintProvider</constraintProviderClass>
    </scoreDirectorFactory>

    <!-- Phase 1: Custom Phase - Assign timeslots with matching lengths -->
    <!-- This phase ensures that each block is assigned to a timeslot with matching length
         BEFORE the construction heuristic runs. This prevents the construction heuristic
         from creating invalid assignments. -->
    <customPhase>
        <customPhaseCommandClass>com.example.solver.MatchingLengthTimeslotAssigner</customPhaseCommandClass>
        <termination>
            <stepCountLimit>10000</stepCountLimit>
        </termination>
    </customPhase>

    <!-- Phase 2: Construction Heuristic - ENABLED -->
    <!-- FIRST_FIT_DECREASING: Assigns values to planning variables in decreasing difficulty order.
         Uses BlockLengthDifficultyComparator to schedule longer blocks (4h, 3h) first,
         leaving shorter blocks (1h, 2h) to fill gaps. This reduces fragmentation.

         IMPORTANT: Phase 1 pre-assigns timeslots with matching lengths, so Construction Heuristic
         only needs to assign timeslots to remaining unassigned blocks (if any).
         Move filters in Phase 4 ensure that Construction Heuristic respects block length constraints. -->
    <constructionHeuristic>
        <constructionHeuristicType>FIRST_FIT_DECREASING</constructionHeuristicType>
    </constructionHeuristic>

    <!-- Phase 3: Defragmentation Phase - Fix schedule fragmentation -->
    <!-- This phase runs AFTER the construction heuristic to detect and fix fragmentation.
         Fragmentation occurs when a day's schedule is filled with small blocks (e.g., 1-hour BASICAS)
         that prevent larger blocks (e.g., 3-4 hour non-BASICAS) from being assigned to contiguous timeslots.
         This phase:
         1. Detects blocks with mismatched lengths (violations)
         2. Finds suitable contiguous timeslots for these blocks
         3. Moves conflicting smaller blocks to create space
         4. Assigns the larger block to the cleared contiguous slot -->
    <customPhase>
        <customPhaseCommandClass>com.example.solver.BlockDefragmenter</customPhaseCommandClass>
        <termination>
            <stepCountLimit>5000</stepCountLimit>
        </termination>
    </customPhase>

    <!-- Phase 4: Local Search (Improvement) -->
    <!-- Uses multiple algorithms for better exploration:
         - Late Acceptance: Good for escaping local optima
         - Tabu Search: Prevents cycling back to recent solutions -->
    <localSearch>
        <unionMoveSelector>
            <!-- Change 1 variable (timeslot) -->
            <!-- Filter to ensure block length matches timeslot length -->
            <changeMoveSelector>
                <filterClass>com.example.solver.MatchingLengthMoveFilter</filterClass>
            </changeMoveSelector>
            <!-- Swap assignments between two entities -->
            <!-- Filter to prevent swaps between assignments with different block lengths -->
            <swapMoveSelector>
                <filterClass>com.example.solver.MatchingLengthSwapFilter</filterClass>
            </swapMoveSelector>
            <!-- Pillar swap: swap groups of assignments with same value -->
            <!-- <pillarSwapMoveSelector/> -->
        </unionMoveSelector>
        <acceptor>
            <!-- Late Acceptance: accepts moves based on score from N steps ago -->
            <!-- Optimized to 10000 for better performance while maintaining exploration -->
            <lateAcceptanceSize>10000</lateAcceptanceSize>
            <!-- Tabu Search: prevents cycling back to recent solutions -->
            <entityTabuSize>7</entityTabuSize>
        </acceptor>
        <forager>
            <acceptedCountLimit>1</acceptedCountLimit>
        </forager>
        <termination>
            <!-- Stop when we find a feasible solution (0 hard violations) -->
            <bestScoreLimit>0hard/-800soft</bestScoreLimit>
            <!-- Or after 100 minutes total -->
            <minutesSpentLimit>120</minutesSpentLimit>
            <!-- Or after 15 minutes without improvement (allows more patience to escape local optima) -->
            <unimprovedMinutesSpentLimit>15</unimprovedMinutesSpentLimit>
        </termination>
    </localSearch>
</solver>
